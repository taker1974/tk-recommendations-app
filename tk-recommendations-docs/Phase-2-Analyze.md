# Этап 2. Анализ требований

## 1. Краткое изложение задания и вывод

Из задания:

```Text
Динамические правила
Вам необходимо создать API в вашей системе для динамического добавления правил рекомендаций и рекомендуемых продуктов.
Само АПИ должно состоять из трех методов:
- добавление правила,
- удаление правила,
- получение списка всех правил.
Вначале дадим определение динамическому правилу и опишем его основные компоненты на примере одного из правил первого технического задания.
Для рекомендации продукта «Простой кредит» мы использовали следующий набор правил:

Пользователь не использует продукты с типом CREDIT.
Сумма пополнений по всем продуктам типа DEBIT больше, чем сумма трат по всем продуктам типа DEBIT.
Сумма трат по всем продуктам типа DEBIT больше, чем 100 000 ₽.
Динамическое правило для этого продукта будет выглядеть следующим образом:

[
    {
        "query": "USER_OF",
        "arguments": [
            "CREDIT"
        ],
        "negate": true
    },
    {
        "query": "TRANSACTION_SUM_COMPARE_DEPOSIT_WITHDRAW",
        "arguments": [
            "DEBIT",
            ">"
        ],
        "negate": false
    },
    {
        "query": "TRANSACTION_SUM_COMPARE",
        "arguments": [
            "DEBIT",
            "DEPOSIT"
            ">",
            "100000"
        ],
        "negate": false
    }
]
```

Необходимо реализовать возможность для каждого продукта задавать список "правил" (вызовов RPC), и на основе суммы результатов выполнения RPC рекомендовать продукт пользователю.

То есть по сути "динамические правила" - это список RMI с необходимыми параметрами.
Т.к.
        "arguments": [
            "CREDIT"
        ]
не содержит имени поля, то можно предположить, что "arguments" - это `List<String>`.

## Требуемые к реализации RMI

**USER_OF**: является пользователем продукта.

Пользователь продукта X — этот пользователь, у которого есть хотя бы одна транзакция по продукту.

```Json
{
        "query": "USER_OF",
        "arguments": [
            "CREDIT"
        ],
        "negate": true
}
// negate == !USER_OF
```

**ACTIVE_USER_OF**: является активным пользователем продукта.

Активный пользователь продукта X — это пользователь, у которого есть хотя бы пять транзакций по продукту.

```Json
{
        "query": "ACTIVE_USER_OF",
        "arguments": [
            "DEBIT"
        ],
        "negate": false
}
```

**TRANSACTION_SUM_COMPARE**: сравнение суммы транзакций с константой.

```Json
{
        "query": "TRANSACTION_SUM_COMPARE",
        "arguments": [
            "DEBIT",
            "DEPOSIT",
            ">",
            "100000"
        ],
        "negate": false
}
```

**TRANSACTION_SUM_COMPARE_DEPOSIT_WITHDRAW**: сравнение суммы пополнений с тратами по всем продуктам одного типа.

Этот запрос сравнивает сумму всех транзакций типа DEPOSIT с суммой всех транзакций типа WITHDRAW по продукту X.

```Json
{
        "query": "TRANSACTION_SUM_COMPARE_DEPOSIT_WITHDRAW",
        "arguments": [
            "DEBIT",
            ">"
        ],
        "negate": false
}
```

ОБНОВЛЕНИЕ ПО РЕЗУЛЬТАТАМ КОНСУЛЬТАЦИИ С ИЛЬЁЙ САВИНОВЫМ 31.03.2025 21:00:

- встроенные правила остаются;
- один продукт - одно правило ("правило", rule - список query);
- внутри правила все результаты объединяются по "И", и при этом в задании нет и не предусматривается объединения по "ИЛИ".

То есть:

- сначала проверяем пользователя по "статическим" (вшитым в код) правилам, добавляем рекомендации в список;
- затем проверяем пользователя по динамическим правилам.

Правило #2 для Top Saving с объединением по "ИЛИ" есть только в коде:
не нужно это реализовывать отдельно в "динамической" части задания.

## Таблицы БД

Каждый продукт связывается с единственным набором правил (OneToMany).
Каждое правило ссылается на свой продукт по ключу продукта. Каждое правило включает в себя список RMI ("query") с аргументами.

   recommendations:
   uuid продукта | name | description

   rules:
   собственный id | [внешний ключ] uuid продукта | query | _аргументы через конвертер_ | negate

Здесь аргументы можно было бы помещать в отдельную сущность rule_arguments/@ElementCollection,
но это нецелесообразно:

- в аргументах важна последовательность и атомарность;
- аргументы имеют очень конечную длину;
- описание API в задании не говорит о том, что список аргументов - это отдельый класс.

## Код

В коде можно восстанавливать

```Java
Recommendation {
    List<Rule> rules;
}
```

и для каждого

```Java
Rule {
    String query;
    List<String> arguments;
}
```

по query вызывать соответствующий метод с передачей ему параметров, преобразованных в/из `List<String>` в требуемые типы.
